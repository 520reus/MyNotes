# 多文件编译问题

## 问题引入

**1.由const或static修饰的全局变量，只能在该文件中访问？可以通过文件包含的方式访问吗？**

答：一个全局变量的作用域默认是整个程序， 加了static 或者加了 const 的全局变量的作用域则是这个源文件，但是可以通过文件包含的方式进行访问，不过作用域也仅限在该源文件中。

**2.多个文件能不能同时包含一个相同的文件？**

答：可以。头文件与文件包含的作用见下文。

**3.#ifndef的作用是什么？**

答：防止多重定义。若头文件只有声明，多次包含是可以的，因为一个变量可以声明多次，但是只能被定义一次。但是头文件中有三个例外，分别是const、static修饰的全局变量，内联函数和类。头文件中可以放这三种内容的定义，所有当多次包含同一个文件时，就会出现重定义的问题。所以#ifndef或者#pragma once这些宏定义的作用就是防止多重定义的发生。因此头文件中先写上以上两种宏定义中的一种是一个很好的编程习惯，也可以避免一些麻烦的事情发生。

**4.const修饰的全局变量被包含头文件后可直接被其他文件使用？**

答：可以。由问题3可知头文件中可以写const或static修饰的全局变量。相当于进行变量的定义，所以其他文件包含该头文件后可以直接访问到该变量。至于问题1的解答说const或static修饰的全局变量作用域只有当前源文件，不能被其他文件访问，可以这样理解：头文件包含其实等价于把头文件的内容直接拷贝到当前源文件，所以还是在同一个文件中，不过作用域也仅限在该文件中！

**5.其他文件如何访问一个文件中定义的全局变量？**

答：使用extern关键字。具体来说有两种方法：

**方法一**:在cpp文件中定义该全局变量，比如int res=5；然后在其他需要访问该变量的文件中写声明:extern int res；告诉编译器该源文件虽然没有定义该变量，但是可以去其他文件中找一找有没有它的定义，然后就可以访问到该变量了。

**方法二**：在.h文件中写声明：extern int res；在.cpp文件中写定义:int res = 5;然后其他文件需要访问该变量时只需要包含该头文件即可。效果其实和方法一是相同的，因为包含头文件其实就是将头文件中的内容拷贝到源文件中，相当于把头文件中的extern int res拷贝到需要它的源文件中了。

## C++编译模式

通常，在一个C++程序中，只包含两类文件——.cpp文件和.h文件。其中，.cpp文件被称作C++源文件，里面放的都是C++的源代码；而.h文件则被称作C++头文件，里面放的也是C++的源代码。

C++支持“**分别编译**”。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的.cpp文件里。.cpp文件里的东西都是相对独立的，在编译时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接就行了。比如，在文件a.cpp中定义了一个全局函数“void a() {}”，而在文件b.cpp中需要调用这个函数。即使这样，文件a.cpp和文件b.cpp并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。

这是怎么实现的呢？ 
 在文件b.cpp中，在调用“void a()”函数之前，先声明一下这个函数“void  a();”，就可以了。这是因为编译器在编译b.cpp的时候会生成一个符号表(symbol table)，像“void  a()”这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。

注意这里提到了两个概念，**一个是“定义”，一个是“声明”**。简单地说，**“定义”就是把一个符号完完整整地描述出来：它是变量还是函数，返回什么类型，需要什么参数等等。而“声明”则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的**，我这里先用着，你链接的时候再到别的地方去找找看它到底是什么吧。定义的时候要按C++语法完整地定义一个符号（变量或者函数），而声明的时候就只需要写出这个符号的原型了。需要注意的是，**一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。试想，如果一个符号出现了两种不同的定义，编译器该听谁的？**

这种机制给C++程序员们带来了很多好处，同时也引出了一种编写程序的方法。考虑一下，如果有一个很常用的函数“void f()  {}”，在整个程序中的许多.cpp文件中都会被调用，那么，我们就只需要在一个文件中定义这个函数，而在其他的文件中声明这个函数就可以了。一个函数还好对付，声明起来也就一句话。但是，如果函数多了，比如是一大堆的数学函数，有好几百个，那怎么办？能保证每个程序员都可以完完全全地把所有函数的形式都 准确地记下来并写出来吗？

## 头文件是什么

很显然，答案是不可能。但是有一个很简单地办法，可以帮助程序员们省去记住那么多函数原型的麻烦：我们可以把那几百个函数的声明语句全都先写好，放在一个文件里，等到程序员需要它们的时候，就把这些东西全部copy进他的源代码中。

这个方法固然可行，但还是太麻烦，而且还显得很笨拙。于是，头文件便可以发挥它的作用了。所谓的头文件，其实它的内容跟.cpp文件中的内容是一样的，都是C++的源代码。但头文件不用被编译。**我们把所有的函数声明全部放进一个头文件中，当某一个.cpp源文件需要它们时，它们就可以通过一个宏命令  “#include”包含进这个.cpp文件中，从而把它们的内容合并到.cpp文件中去。**当.cpp文件被编译时，这些被包含进去的.h文件的作用便发挥了。

## 头文件应该写什么

**头文件中应该只放变量和函数的声明，而不能放它们的定义**。因为一个头文件的内容实际上是会被引入到多个不同的.cpp文件中的，并且它们都会被编译。放声明当然没事，如果放了定义，那么也就相当于在多个文件中出现了对于一个符号（变量或函数）的定 义，纵然这些定义都是相同的，但对于编译器来说，这样做不合法。

头文件中一般写的是变量声明(extern+全局变量声明，比如：extern int a；)或函数声明（void test()）。**不能在头文件的全局区写int a；因为它不是声明，而是定义！**，

但是有三个例外可以在头文件中写定义：

​	**1.由const或static修饰的全局变量**

​		因为**全局的const对象默认是没有extern的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个.cpp文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，**所以便不会导致多重定义。同时，因为这些.cpp文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些.cpp文件中的这个const对象的值是相同的，可谓一举两得。同理，static对象的定义也可以放进头文件。

​	**2.内联函数（inline）的定义**

​		因为**inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的**（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办  呢？这几乎没什么太好的解决办法，因此C++规定，内联函数可以在程序中定义多次，只要内联函数在一个.cpp文件中只出现一次，并且在所有的.cpp文 件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。

​	3.**类（class）的定义**

​		因为**在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。**所以把类的定义放进头文件，在使用到这个类的.cpp文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就  是我们通常所说的类的实现。一般，我们的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个.cpp文件中。这是可以的，也是很好的办法。  不过，还有另一种办法。那就是直接把函数成员的实现代码也写进类定义里面。在C++的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为  内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中， 这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的.cpp文件包含，这个函数成员就被重定义了。

## 头文件中的保护措施

​		考虑一下，如果头文件中只包含声明语句的话，它被同一个.cpp文件包含再多次都没问题——因为声明语句的出现是不受限制的。然而，上面讨论到的头文件中的三个例外也是头文件很常用的一个用处。那么，一旦一个头文件中出现了上面三个例外中的任何一个，它再被一个.cpp包含多次的话，问题就大了。因为这三个例外中的语法元素虽然“可以定义在多个源文件中”，但是“在一个源文件中只能出现一次”。

使用”#define”配合条件编译可以很好地解决这个问题。在一个头文件中，通过#define定义一个名字，并且通过条件编译#ifndef…#endif使得编译器可以根据这个名字是否被定义，再决定要不要继续编译该头文中后续的内容。这个方法虽然简单，但是写头文件时一定记得写进去。也可以用#pragma once

## .hpp文件

​		.hpp文件一般是类的头文件，实质就是将.cpp的实现代码混入.h头文件中，定义与实现都包含在同一个文件，则该类的调用者只需要include该hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，**采用hpp将大幅减少调用project中的cpp文件数与编译次数，也不用再发布烦人的lib与dll**，因此非常适合用来编写公用的开源库。

1. 是Header Plus Plus的缩写
2. 是一般模板类的头文件
3. 一般来说，.h里面只有声明，没有实现，而.hpp里声明和实现都有，后者可以减少.cpp的数量
4. .h里面可以有using namespace std，而.hpp里面则无

.hpp要注意的问题：

1. **不可包含全局对象和全局函数**
    由于hpp本质上是作为.h被调用者include，所以当hpp文件中存在全局对象或者全局函数时，若该hpp被多个调用者include，将在链接时导致符号重定义错误。要避免这种情况，需要去除全局对象，将全局函数封装为类的静态方法。
2. 类之间不可以循环调用

