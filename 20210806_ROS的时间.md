# ROS的时间

## ROS::Time()vsROS::WallTime()

谈及时间，有一个很重要的概念是**ROS Time**和**Wall Time**，两者是有区别的。它们两个的接口完全一样，数据类型也一样，但是ROS Time表示的是ROS网络中的时间。

ROS网络中的时间是指，如果当时在非仿真环境里运行，那它就是当前的时间。但是假设去回放当时的情况，那就需要把当时的时间录下来。以控制为例，很多的数据处理需要知道当时某一个时刻发生了什么。**Wall Time**可以理解为墙上时间，墙上挂着的时间没有人改变的了，永远在往前走；**ROS Time可以被人为修改，你可以暂停它，可以加速，可以减速，但是Wall Time不可以。**

在开启一个Node之前，当把use_sim_time设置为true时，这个节点会从clock Topic获得时间。所以操作这个clock的发布者，可以实现一个让Node中得到ROS Time暂停、加速、减速的效果。同时下面这些方面都是跟Node透明的，所以非常适合离线的调试方式。当把ROSbag记下来以后重新play出来时，加两个横杠，--clock，它就会发布出这个消息。

一、Time
1、时刻和间隔
ROS 中有 time 和 duration 两种类型，相应的有 ros::Time 和 ros::Duration 类。

time 表示的是时刻
duration 表示的是时间间隔
其统一表示形式为：

    int32 sec
    int32 nsec

ROS 可以给节点提供一个模拟始时钟。不同于平台时间，你可以利用 roscpp 的时间例程来得到当前的时间，此时间能够和模拟时间、wall-clock 时间进行无缝连接。
1.1 获得当前时间

    ros::Time::now()
    ros::Time begin = ros::Time::now();

Wall Time

在模拟时，如果想要进入实际运行 wall-clock time ，可以用 ros::WallTime, ros::WallDuration, 和ros::WallRate，类似于 ros::Time, ros::Duration, 和 ros::Rate

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

（1）三种时间的定义

时钟时间(墙上时钟时间wall clock time)：从进程从开始运行到结束，时钟走过的时间，这其中包含了进程在阻塞和等待状态的时间。
用户CPU时间：就是用户的进程获得了CPU资源以后，在用户态执行的时间。
系统CPU时间：用户进程获得了CPU资源以后，在内核态的执行时间。

（2）三者之间的关系

进程的三种状态为阻塞、就绪、运行。
时钟时间 ＝ 阻塞时间 ＋ 就绪时间 ＋运行时间
用户CPU时间 ＝ 运行状态下用户空间的时间
系统CPU时间 = 运行状态下系统空间的时间。
用户CPU时间+系统CPU时间=运行时间。

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

CPU时间

进程时间也称CPU时间，用以度量进程使用的中央处理器资源。进程时间以时钟嘀嗒计算，实际时间（Real），用户CPU时间（User），系统CPU时间（Sys）

实际时间指实际流逝的时间；用户时间和系统时间指特定进程使用的CPU时间：

 

real time是从进行开始执行到完成所经历的墙上时钟时间（wall clock）时间，包括其他进程使用的时间片（time slice）和本进程耗费在阻塞（如等待I/O操作完成）上的时间。
user time是进程执行用户态代码（内核外）耗费的CPU时间，仅统计该进程执行时实际使用的CPU时间，而不计入其他进程使用的时间片和本进程阻塞的时间
sys time 是该进程在内核态运行所耗费的CPU时间，即内核执行系统调用所使用的CPU时间

 


CPU总时间（user + sys）是CPU执行用户进程操作和内核（代表用户进程执行）系统调用所耗时间的总和，即该进程（包括线程和子进程）所使用的实际CPU时间。若程序循环遍历数组，则增加用户CPU时间；若程序执行exec或fork等系统调用，则增加系统CPU时间。

在多核处理器机器上，若进程含有多个线程或通过fork调用创建子进程，则实际时间可能小于CPU总时间，因为不同线程或进程可并行执行，但其时间会计入主进程的CPU总时间。若程序在某段时间处于等待状态而并未执行，则实际时间可能大于CPU总时间：

    real < CPU  表明进程为计算密集型（CPU bound），利用多核处理器的并行执行优势
    real ≈ CPU  表明进程为计算密集型，未并行执行
    real > CPU  表明进程为I/O密集型 （I/O bound），多核并行执行优势并不明显
