本文档主要总结《C++ Primer Plus》第六版，第9章——内存模型和名称空间的内容

引言：C++为在内存中存储数据提供了多种选择，可以选择数据保留在内存的时间长度（存储持续性），以及程序的哪一个部分可以访问数据（作用域与链接性）。名称空间是另一种控制访问权的方式。通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据，这样的程序涉及到程序文件的单独编译。

## 一、单独编译

在大型项目中，如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本进行链接。这使得大程序的管理更便捷更快速。

### 1.头文件应该放什么?

头文件中常包含：

- 函数原型
- 使用#define或const定义的符号常量
- 结构声明
- 类声明
- 模板声明
- 内联函数

**不要将函数定义或变量声明放到头文件中！**

### 2.头文件管理

在同一个文件中只能将同一个头文件包含一次，但是可能在不知情的情况下将头文件包含多次。有两种方法可以避免多次包含头文件：

法一：

```c++
#ifndef LOG_H_//假如头文件名为log.h
#define LOG_H_
//place include file contexts here
#endif
```

法二：

```
#pragma once
```

### 3.编译（翻译）单元（translation unit）

编译单元：当一个c或cpp文件在编译时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，每个.cpp文件就是一个编译单元。事实上编译每个编译单元时是相互独立的，即每个cpp文件是不知道对方存在的，编译器会分别将每个编译单元(.cpp)进行编译，生成相应的目标文件，然后链接器会将所有的目标文件进行链接，生成最终的可执行文件。



## 二、存储持续性、作用域和链接性

C++使用三种（c++11中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存的时间。

- 自动存储连续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其相应代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。
- 静态存储持续性：在函数外定义的变量和使用关键字static定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有三种存储持续性为静态的变量。
- 线程存储持续性（C++11）：变量使用thread_local声明，则其生命周期与所属线程一样长。
- 动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自动存储（free store）或堆（heap）。线程存储持续性（C++11）：变量使用thread_local声明，则其生命周期与所属线程一样长。

### 1.作用域和链接

**作用域（scope）描述了名称在文件（编/翻译单元）的多大范围内可见。**

- 作用域为局部的变量只能在定义它的代码块中可用。函数体就是代码块，代码块是由花括号括起的一系列语句，代码块中可以嵌套其他代码块。
- 作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。
- 在函数原型作用域（function prototype scope)中使用的名称只在包含参数列表的括号中可用，这就是为什么这些名称是什么以及是否出现都不重要的原因。
- 在类中声明的成员的作用域为整个类。  
- 在名称空间声明的变量的作用域为整个名称空间。
- 自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。

**链接性（linkage）描述了名称如何在不同文件间共享。**

链接性为外部的名称可在文件间共享，比如全局变量等。链接性为内部的名称只能由一个文件中的函数共享，比如static函数，inline函数等。自动变量的名称没有链接性，因为它们不能共享。

### 2.自动存储连续性

在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。

如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。

#### 自动变量的初始化

```c++
int w;    				
int x = 5;  		    
int big = INT_MAX-1;
int y = 2*x;
cin>>w;
int z = 3*w;
```

#### 自动变量和栈

自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理，常用方法是留出一段内存，并将其视为栈，以管理变量的增减。

### 3.静态持续变量

C++为静态存储持续性变量提供了三种链接性：外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块中访问）。这三种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。如果没有显示地初始化静态变量，编译器将把它设置为0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设为0。

#### 如何创建不同链接性的静态持续变量？

- 若想创建链接性为外部的静态持续变量，必须在代码块外声明它。
- 若想创建连接性为内部的静态持续变量，必须在代码块外声明它，并且用static限定符修饰。
- 若想创建没有链接性的静态持续变量，必须在代码块内声明它，并且用static限定符修饰。

​											             **5种变量存储方式**

|     储存描述     | 持续性 | 作用域 | 链接性 | 如何声明                       |
| :--------------: | :----: | ------ | ------ | ------------------------------ |
|       自动       |  自动  | 代码块 | 无     | 在代码块中                     |
|      寄存器      |  自动  | 代码块 | 无     | 在代码块中，使用关键字register |
|  静态，无链接性  |  静态  | 代码块 | 无     | 在代码块中，使用关键字static   |
| 静态，外部链接性 |  静态  | 文件   | 外部   | 在代码块外                     |
| 静态，内部链接性 |  静态  | 文件   | 内部   | 在代码块外，使用关键字static   |

#### 静态变量的初始化

除默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化。

```c++
#include<cmath>
int x;    #零初始化
int y=5;  #常量初始化
long z = 13*13; #常量表达式初始化（编译前初始化）
const double pi = 4.0*atan(1.0); #动态初始化（编译后初始化）
```

#### 静态持续性、外部链接性

链接性为外部的静态持续变量简称为外部变量或全局变量。它们的存储持续性为静态，作用域为整个文件。

**单定义规则**

变量可以多次声明，但是只能有一次定义，为满足该需求，C++提供了两种变量声明。一种是定义声明，简称为定义（definition），它给变量分配存储空间。另一种是引用声明，简称为声明（declaration），它不给变量分配存储空间，因为它引用已有的变量。

引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间。

```
double up;  //定义，up=0
extern int blem; //外部声明，表示在该文件使用其他文件中的blem变量
extern char gr = 'z'; //定义，表示该文件中的gr变量可被外部文件使用，且初值为'z'
```

如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字extern声明它。

```
//file01.cpp
extern int cats = 20;(关键字并非必不可少)
int dogs = 22;
int fleas;

//file02.cpp
//use cats and dogs from file01.cpp
extern int cats;
extern int dogs;
//file02.cpp未写extern声明，因此无法使用file01.cpp的fleas

//file98.cpp
//use cats and dogs and fleas from file01.cpp
extern int cats;
extern int dogs;
extern fleas;
```

#### 静态持续性、内部链接性

将static限定符用于作用域为整个文件的变量时，该变量的链接性为内部的。在多文件程序中，内部链接性与外部链接性之间的差别很有意义。链接性为内部的变量只能在其所属的文件中使用；但常规外部变量都有外部链接性，可以在其他文件中使用。

如果要在其他文件中使用相同的名称来表示其他变量，该怎么办呢？

```c++
//file1
int erros = 20; //external declaration
------------
//file2
int erros = 5; //error
```

这种做法将失败，因为它违反了单定义规则，因为erros在两个文件均为静态持续变量，外部链接性。但是定义了两次，此时方法是将其中一个文件的变量用static限定符修饰，使其链接性变为内部的，可在该文件中隐藏同名外部变量。

```
//file1
int erros = 20; //external declaration
------------
//file2
static int erros = 5; //仅在file2文件内可见
```

**因此在多文件程序中，可以在一个文件且只能在一个文件中定义一个外部变量，使用该变量的其他文件必须使用关键字extern声明它！**

> 总结

可使用外部变量在多文件程序的不同部分之间共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（名称空间提供了另外一种共享数据的方法）。

#### 静态存储持续性、无链接性

这种变量是这样创建出来的：将static限定符用于在代码块中定义的变量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。这意味着虽然该变量只在该代码块中可用，但在该代码块不处于活跃状态时仍然存在。因此在两次函数调用之间，静态局部变量的值将保持不变。 

#### 说明符和限定符

存储说明符：

- auto（在C++中不再是说明符）
- register
- static
- extern
- thread_local（C++11新增的）
- mutable

cv-限定符

- const
- volatile

#### const详解

在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，在c++看来，全局const定义就像使用了static限定符一样

```
const int fingers = 10; //same as static const int fingers = 10;
```

C++修改了常量类型的规则，让程序员更轻松。例如，假设将一组常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那么，预处理将头文件的内容包含到每个源文件中，所有的源文件都将包含类似下面的定义：

```
const int fingers = 10;
const char* warning = "wak!";
```

**内部链接性意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量。**每个定义都是其所属文件私有的，这就是能够将常量定义在头文件的原因。这样，只要在两个源代码文件中包含同一个头文件，则它们将获得同一组常量。

如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性：

```
extern const int states = 10;
```

在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它，这与常规外部变量不同，定义常规外部变量时，不必使用extern关键字，但在使用该变量的其他文件中必须使用extern。然而，请记住，鉴于单个const在多个文件之间共享，因此只有一个文件可对其进行初始化。

在函数或代码块中声明const时，其作用域为代码块，即仅当程序执行该代码块中的代码时，该常量才是可用的。

#### 函数和链接性

所有函数的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为外部的，即可以在文件间共享。还可以用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字：

static int private(double x);

static int private(double x){...}

这意味着该函数只在这个文件中可见，意味着可以在其他文件中定义中定义同名的函数。

内敛函数不受这个规则的约束，这允许程序员能够将内敛函数放在头文件中，这样，包含了头文件的每个文件都有内敛函数的定义。

#### 存储方案和动态分配

前面介绍C++用来为变量分配内存的5种方案，它们不适用于适用C++运算符new（或C函数malloc（））分配的内存，这种内存被称为动态内存。

## 三、名称空间

### 已有名称空间的属性

**声明区域（declaration region）**

声明区域是可以在其中进行声明的区域，比如，可以**在函数外面声明全局变量**，对于这种变量，其声明区域为其声明**所在的文件**。对于在**函数中声明的变量**，声明区域为其声明**所在的代码块**。

**潜在作用域（potential scope）**

从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小。

然而并非在其潜在作用域内的任何位置都是可见的

```c++
int ro = 10;
int main()
{
	int go;
    int ro;  //局部变量
    system("pause");
    return 0;
}
```

在int main()外面定义一个全局变量ro，该全局变量的潜在作用域是从第1句到第4句，因为在函数中声明的局部变量会**隐藏**全局变量，使得在函数代码块内从局部变量定义开始往后，均为局部变量的作用域。

### 新的名称空间特性

通过定义一种新的声明区域来创建命名的名称空间。使得一个名称空间中的名称不会和其他名称空间中的名称冲突，同时允许程序的其他部分使用该名称空间中声明的东西。

**名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块！因此，在默认情况下，在名称空间中声明的名称的链接性是外部的（除非它引用了常量）**

除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间，它对应于文件级声明区域，因此全局变量现在被定义在全局名称空间中。

### 如何访问名称空间？

当然，需要有一种方法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析符::，使用名称空间来限定该名称。

```
Apollo::localization::m = 5 //using a variable
Apollo::planning PLAN; //using a class 
Apollo::control::sendMessage();//using a function
```

违背修饰的名称（如m）成为未限定的名称；包含名称空间的名称（如Apollo::localization::m）称为限定的名称。

### using声明和using编译指令

我们并不希望每次使用名称时都对它进行限定，因此C++提供两种机制(using声明和using编译声明)

**using 声明**

```
using Apollo::control::sendMessage(); 
```

在using声明语句后，就不用加限定，直接使用sendMessage（）即可。但是control名称空间中的其他内容仍然无法访问。

**using编译指令**

```
using namespace Apollo:control;
```

using编译指令使整个名称空间可用。

**比较**

using声明比using编译指令更安全，这是由于它只导入指定的名称，如果该名称与局部名称冲突，编译器将发出指示。using编译指令导入所有名称，包括可能并不需要的名称，如果与局部名称发生冲突，则局部名称将**覆盖**名称空间版本，而编译器不会发出警告。

因此更推荐使用using声明，用谁声明谁。



### 名称及其用途

- 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。

- 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。

- **不要在头文件使用using编译指令！**。首先这掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序行为，如果非要使用using编译指令，应将其放在所有预处理器编译命令#include后

  **如果你的头文件(.h、.cpp)有被外部使用，则不要使用任何using语句引入其他命名空间或其他命名空间中的标识符。因为这可能会给使用你的头文件的人添麻烦**。

  **但是在源文件(.cpp)里面怎么用using都是没有关系的，因为cpp的代码不影响到他人，甚至如果你的头文件(.h、.hpp)只是自己用，那using也是没事的**。

- 如果开发了一个函数库和类库，将其放在一个名称空间中。

- 导入名称时，首选作用域解析运算符或using声明的方法。

- 对于using声明，首选将其作用域设置为局部而不是全局。